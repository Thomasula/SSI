# -*- coding: utf-8 -*-
"""SSIproject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KYac1wu92aYLSlT2WQZoAtKfALXTaqqI
"""

import pandas as pd
import numpy as np
import math as math
from matplotlib import pyplot as plt
import warnings

warnings.simplefilter(action='ignore', category=FutureWarning)

pd.options.mode.chained_assignment = None  # default='warn'

def init_peds(N_ped, const):

   const['N_ped'] = N_ped

   start_x = np.random.uniform(const['wx1'] + 0.1, const['wx2'] - 0.1, N_ped)
   start_y = np.random.uniform(const['wy1'] + 0.1, const['wy2'] - 0.1, N_ped)

   ped_data = pd.DataFrame({
   't': [[] for _ in range(const['N_ped'])],
   'vx': [[0] for _ in range(const['N_ped'])],
   'vy': [[0] for _ in range(const['N_ped'])],
   'x': [[start_x[i]] for i in range(const['N_ped'])],
   'y': [[start_y[i]] for i in range(const['N_ped'])],
   'ped_id': [i+1 for i in range(const['N_ped'])],
   'time_left': [np.nan for _ in range(const['N_ped'])]
   })

   # add peds one by one

   # t =  np.random.rand(const['N_ped'])*0
   # x =  np.random.rand(const['N_ped'])*const['wx2']
   # y =  np.random.rand(const['N_ped'])*const['wy2']
   # vx = np.random.rand(const['N_ped'])*0
   # vy = np.random.rand(const['N_ped'])*0
   # ex = np.random.rand(const['N_ped'])*10


   # rep = range(len(x)-1)
   # for i in rep:
   #     ped_data_n = pd.DataFrame({'ped_id': i+1,
   #                             't': [[t[i+1]]],
   #                             'x': [[x[i+1]]],
   #                             'y': [[y[i+1]]],
   #                             'vx': [[vx[i+1]]],
   #                             'vy': [[vy[i+1]]],
   #                             'time_left': ex[i+1]
   #                             }, index = [i+1])
   #     ped_data = pd.concat([ped_data,ped_data_n])

   return ped_data, const


def one_ped_step(ped_data, ped_idx, act_t, act_vx, act_vy, const):
   # performs one step of one ped with respect to the new velocity

   ped_data['t'].iloc[ped_idx] = ped_data['t'].iloc[ped_idx] + [act_t]

   new_x = ped_data['x'].iloc[ped_idx][-1] + act_vx * const['dt']
   new_y = ped_data['y'].iloc[ped_idx][-1] + act_vy * const['dt']

   # Ensure new_x and new_y are scalars
   if np.isscalar(new_x):
       # hard core zero-range wall repulsion

       if new_x < const['wx1']:
           new_x = const['wx1'] + 0.0001
           act_vx = 0
       if new_x > const['wx2']:
           new_x = const['wx2'] - 0.0001
           act_vx = 0
   else:
       new_x = np.clip(new_x, const['wx1'], const['wx2'])
       act_vx = np.where(new_x == const['wx1'], 0, act_vx)
       act_vx = np.where(new_x == const['wx2'], 0, act_vx)


   if np.isscalar(new_y):
       if new_y < const['wy1']:
           new_y = const['wy1'] + 0.0001
           act_vy = 0
       if new_y > const['wy2']:
           new_y = const['wy2'] - 0.0001
           act_vy = 0
   else:
       new_y = np.clip(new_y, const['wy1'], const['wy2'])
       act_vy = np.where(new_y == const['wy1'], 0, act_vy)
       act_vy = np.where(new_y == const['wy2'], 0, act_vy)

   ped_data['x'].iloc[ped_idx] += [new_x]
   ped_data['y'].iloc[ped_idx] += [new_y]
   ped_data['vx'].iloc[ped_idx] += [act_vx]
   ped_data['vy'].iloc[ped_idx] += [act_vy]

   return ped_data


def f_motivation(ped_data, ped_idx, const):
   if len(ped_data.loc[ped_idx, 'x']) == 0 or len(ped_data.loc[ped_idx, 'y']) == 0:
       raise ValueError(f"Pedestrian {ped_idx} has no recorded position data.")
   last_x = ped_data['x'].iloc[ped_idx][-1]
   last_y = ped_data['y'].iloc[ped_idx][-1]

   last_vx = ped_data['vx'].iloc[ped_idx][-1]
   last_vy = ped_data['vy'].iloc[ped_idx][-1]

   fx = 0
   fy = 0

  #  distance = math.sqrt((const['attractor_x'] - last_x) ** 2 + (const['attractor_y'] - last_y) ** 2)
  #  if distance == 0:
  #       sx = sy = 0
  #  else:
  #       sx = (const['attractor_x'] - last_x) / distance
  #       sy = (const['attractor_y'] - last_y) / distance

  #  fx = (const['v_opt'] * sx - last_vx) / const['tau']
  #  fy = (const['v_opt'] * sy - last_vy) / const['tau']

   # Hallway attractor - exit
   if last_x < const['wx6'] and last_y > const['wy6'] and last_y < const['wy2']:
      distance = math.sqrt((const['attractor_x'] - last_x) ** 2 + (const['attractor_y'] - last_y) ** 2)
      if distance == 0:
          sx = sy = 0
      else:
          sx = (const['attractor_x'] - last_x) / distance
          sy = (const['attractor_y'] - last_y) / distance

      fx = (const['v_opt'] * sx - last_vx) / const['tau']
      fy = (const['v_opt'] * sy - last_vy) / const['tau']

    # Room 1 attractor
   elif last_x > const['wx3'] and last_x < const['wx9'] and last_y > const['wy3'] and last_y < const['wy9']:
      distance = math.sqrt((const['atx2'] - last_x) ** 2 + (const['aty2'] - last_y) ** 2)
      if distance == 0:
          sx = sy = 0
      else:
          sx = (const['atx2'] - last_x) / distance
          sy = (const['aty2'] - last_y) / distance

      fx = (const['v_opt'] * sx - last_vx) / const['tau']
      fy = (const['v_opt'] * sy - last_vy) / const['tau']

    # Room 2 attractor
   elif last_x > const['wx11'] and last_x < const['wx6'] and last_y > const['wy11'] and last_y < const['wy6']:
      distance = math.sqrt((const['atx3'] - last_x) ** 2 + (const['aty3'] - last_y) ** 2)
      if distance == 0:
          sx = sy = 0
      else:
          sx = (const['atx3'] - last_x) / distance
          sy = (const['aty3'] - last_y) / distance

      fx = (const['v_opt'] * sx - last_vx) / const['tau']
      fy = (const['v_opt'] * sy - last_vy) / const['tau']

    # Room 3 attractor
   elif last_x > const['wx1'] and last_x < const['wx4'] and last_y > const['wy1'] and last_y < const['wy4']:
      distance = math.sqrt((const['atx4'] - last_x) ** 2 + (const['aty4'] - last_y) ** 2)
      if distance == 0:
          sx = sy = 0
      else:
          sx = (const['atx4'] - last_x) / distance
          sy = (const['aty4'] - last_y) / distance

      fx = 2 * (const['v_opt'] * sx - last_vx) / const['tau']
      fy = 2 * (const['v_opt'] * sy - last_vy) / const['tau']

   # Room 4 attractor
   elif last_x > const['wx5'] and last_x < const['wx2'] and last_y > const['wy1'] and last_y < const['wy2']:
      distance = math.sqrt((const['atx5'] - last_x) ** 2 + (const['aty5'] - last_y) ** 2)
      if distance == 0:
          sx = sy = 0
      else:
          sx = (const['atx5'] - last_x) / distance
          sy = (const['aty5'] - last_y) / distance

      fx = (const['v_opt'] * sx - last_vx) / const['tau']
      fy = (const['v_opt'] * sy - last_vy) / const['tau']

   return fx, fy


def f_ped_rep(ped_data, ped_idx, other_idx, const):
   if ped_idx == other_idx:
       fx = 0
       fy = 0
   else:
       last_x_ped = ped_data['x'].iloc[ped_idx][-1]
       last_y_ped = ped_data['y'].iloc[ped_idx][-1]
       last_x_other = ped_data['x'].iloc[other_idx][-1]
       last_y_other = ped_data['y'].iloc[other_idx][-1]

       # Calculate distance between two pedestrians
       d = math.sqrt((last_x_ped - last_x_other)**2 + (last_y_ped - last_y_other)**2)

       # Calculate the potential and scaling factors
       U = const['U0'] / const['distance_scale'] * math.exp(-d / const['distance_scale'])

       # Calculate the directional influence (sx, sy) based on distance components
       if d != 0:
           sx = (last_x_other - last_x_ped) / d
           sy = (last_y_other - last_y_ped) / d

       else:
           sx = 0
           sy = 0
       # Compute the repulsive forces in x and y directions
       fx = U * sx
       fy = U * sy

   return fx, fy


def calc_ped_interaction(ped_data, ped_idx, const):
   fx = 0
   fy = 0

   rep = range(const['N_ped'])
   for k in rep:
       if np.isnan(ped_data.time_left[0]):
           fx_one, fy_one = f_ped_rep(ped_data, ped_idx, 0, const)
           fx = fx - fx_one
           fy = fy - fy_one
   return fx, fy


def f_wall(ped_data, ped_idx, const):
   last_x = ped_data['x'].iloc[ped_idx][-1]
   last_y = ped_data['x'].iloc[ped_idx][-1]
   fx = 0
   fy = 0
  #  if last_x < const['wx1'] / 2:
  #     Ux = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wx1'] - last_x) / const['distance_scale_w'])
  #     fx += Ux
  #  else:
  #     Ux = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * last_x / const['distance_scale_w'])
  #     fx += -1 * Ux
  #  if last_y < const['wy1'] / 2:
  #     Uy = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wy1'] - last_y) / const['distance_scale_w'])
  #     fy += Uy
  #  else:
  #     Uy = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * last_y / const['distance_scale_w'])
  #     fy += -1 * Uy

  #  if last_x > const['wx2'] / 2:
  #     Ux = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wx2'] - last_x) / const['distance_scale_w'])
  #     fx += -1 * Ux
  #  else:
  #     Ux = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * last_x / const['distance_scale_w'])
  #     fx += Ux
  #  if last_y > const['wy2'] / 2:
  #     Uy = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wy2'] - last_y) / const['distance_scale_w'])
  #     fy += -1 * Uy
  #  else:
  #     Uy = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * last_y / const['distance_scale_w'])
  #     fy += Uy

  #  if last_y < const['wy3'] / 2 and last_x > const['wx3'] and last_x < const['wx4']:
  #     Uy = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wy3'] - last_y) / const['distance_scale_w'])
  #     fy += -1 * Uy
  #  elif last_y > const['wy3'] / 2 and last_x > const['wx3'] and last_x < const['wx4']:
  #     Uy = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * last_y / const['distance_scale_w'])
  #     fy += Uy

  #  if last_x < const['wx5'] / 2 and last_y > const['wy5'] and last_y < const['wy6']:
  #     Ux = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wx5'] - last_x) / const['distance_scale_w'])
  #     fx += -1 * Ux
  #  elif last_x > const['wx5'] / 2 and last_y > const['wy5'] and last_y < const['wy6']:
  #     Ux = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * last_x / const['distance_scale_w'])
  #     fx += Ux

  #  if last_y < const['wy7'] / 2 and last_x > const['wx7'] and last_x < const['wx8']:
  #     Uy = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wy7'] - last_y) / const['distance_scale_w'])
  #     fy += -1 * Uy
  #  elif last_y > const['wy7'] / 2 and last_x > const['wx7'] and last_x < const['wx8']:
  #     Uy = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * last_y / const['distance_scale_w'])
  #     fy += Uy

  #  if last_y < const['wy9'] / 2 and last_x > const['wx9'] and last_x < const['wx10']:
  #     Uy = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wy9'] - last_y) / const['distance_scale_w'])
  #     fy += -1 * Uy
  #  elif last_y > const['wy9'] / 2 and last_x > const['wx9'] and last_x < const['wx10']:
  #     Uy = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * last_y / const['distance_scale_w'])
  #     fy += Uy

  #  if last_x < const['wx11'] / 2 and last_y > const['wy11'] and last_y < const['wy9']:
  #     Ux = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wx11'] - last_x) / const['distance_scale_w'])
  #     fx += -1 * Ux
  #  elif last_x > const['wx11'] / 2 and last_y > const['wy11'] and last_y < const['wy9']:
  #     Ux = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * last_x / const['distance_scale_w'])
  #     fx += Ux

   ## Room 1 West wall repulsion
   if last_x > const['wx3'] and last_x <= const['wx9'] / 2 and last_y > const['wy3'] and last_y < const['wy9']:
      Ux = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wx3'] - last_x) / const['distance_scale_w'])
      fx = -1 * Ux
   # Room 1 East wall repulsion
   elif last_x > const['wx3'] and last_x > const['wx9'] / 2 and last_x < const['wx9'] and last_y > const['wy3'] and last_y < const['wy9']:
      Ux = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wx9'] - last_x) / const['distance_scale_w'])
      fx = Ux
   ## Room 1 South wall repulsion
   if last_y > const['wy3'] and last_y <= const['wy8'] / 2 and last_x > const['wx3'] and last_x < const['wx8']:
      Uy = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wy3'] - last_y) / const['distance_scale_w'])
      fy = -1 * Uy
   ## Room 1 North repulsion
   elif last_y > const['wy3'] and last_y > const['wy8'] / 2 and last_y < const['wy8'] and last_x > const['wx3'] and last_x < const['wx8']:
      Uy = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wy8'] - last_y) / const['distance_scale_w'])
      fy = Uy

   ## Room 2 West wall repulsion
   if last_x > const['wx11'] and last_x <= (const['wx6'] + const['wx11']) / 2 and last_y > const['wy11'] and last_y < const['wy6']:
      Ux = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wx11'] - last_x) / const['distance_scale_w'])
      fx = -1 * Ux
   ## Room 2 East wall repulsion
   elif last_x > const['wx11'] and last_x > (const['wx6'] + const['wx11']) / 2 and last_x < const['wx6'] and last_y > const['wy11'] and last_y < const['wy6']:
      Ux = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wx6'] - last_x) / const['distance_scale_w'])
      fx = Ux
   ## Room 2 South wall repulsion
   if last_y > const['wy11'] and last_y <= (const['wy10'] + const['wy11']) / 2 and last_x > const['wx11'] and last_x < const['wx6']:
      Uy = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wy11'] - last_y) / const['distance_scale_w'])
      fy = -1 * Uy
   ## Room 2 North wall repulsion
   elif last_y > const['wy11'] and last_y > (const['wy10'] + const['wy11']) / 2 and last_y < const['wy10'] and last_x > const['wx11'] and last_x < const['wx6']:
      Uy = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wy10'] - last_y) / const['distance_scale_w'])
      fy = Uy

   ## Room 3 West wall repulsion
   if last_x > const['wx1'] and last_x <= const['wx4'] / 2 and last_y > const['wy1'] and last_y < const['wy4']:
      Ux = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wx1'] - last_x) / const['distance_scale_w'])
      fx = -1 * Ux
   ## Room 3 East wall repulsion
   elif last_x > const['wx1'] and last_x > const['wx4'] / 2 and last_x < const['wx4'] and last_y > const['wy1'] and last_y < const['wy5']:
      Ux = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wx4'] - last_x) / const['distance_scale_w'])
      fx = Ux
   # Room 3 South wall repulsion
   if last_y > const['wy1'] and last_y <= const['wy4'] / 2 and last_x > const['wx1'] and last_x < const['wx4']:
      Uy = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wy1'] - last_y) / const['distance_scale_w'])
      fy = -1 * Uy
   ## Room 3 North wall repulsion
   elif last_y > const['wy1'] and last_y > const['wy4'] / 2 and last_y < const['wy4'] and last_x > const['wx1'] and last_x < const['wx4']:
      Uy = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wy4'] - last_y) / const['distance_scale_w'])
      fy = Uy

   ## Room 4 West wall repulsion
   if last_x > const['wx5'] and last_x <= (const['wx2'] + const['wx6']) / 2 and last_y > const['wy1'] and last_y < const['wy6']:
      Ux = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wx5'] - last_x) / const['distance_scale_w'])
      fx = -1 * Ux
   ## Room 4 East wall repulsion
   elif last_x > const['wx5'] and last_x > (const['wx2'] + const['wx6']) / 2 and last_x < const['wx2'] and last_y > const['wy1'] and last_y < const['wy6']:
      Ux = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wx2'] - last_x) / const['distance_scale_w'])
      fx = Ux
   ## Room 4 South wall repuslion
   if last_y > const['wy1'] and last_y <= const['wy6'] / 2 and last_x > const['wx5'] and last_x < const['wx2']:
      Uy = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wy1'] - last_y) / const['distance_scale_w'])
      fy = -1 * Uy
   ## Room 4 North wall repulsion
   elif last_y > const['wy1'] and last_y > const['wy6'] / 2 and last_y < const['wy6'] and last_x > const['wx5'] and last_x < const['wx2']:
      Uy = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wy6'] - last_y) / const['distance_scale_w'])
      fy = Uy

   ## Hallway West wall marks the exit point with attractor, so no repulsion
   ## Hallway East wall is the entrance to Room 4 so no repulsion for now

   ## Hallway South wall repulsion
   if last_y > const['wy6'] and last_y <= (const['wy2'] + const['wy6']) / 2 and last_x < const['wx6']:
      Uy = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wy6'] - last_y) / const['distance_scale_w'])
      fy = -1 * Uy
   ## Hallway North wall repulsion
   elif last_y > const['wy6'] and last_y > (const['wy2'] + const['wy6']) / 2 and last_y < const['wy2'] and last_x < const['wx6']:
      Uy = const['U0_w'] / const['distance_scale_w'] * math.exp(-1 * (const['wy2'] - last_y) / const['distance_scale_w'])
      fy = Uy


   return fx, fy


def update_v(ped_data, ped_idx, model_name, const):
   if model_name == 'no_change':
       fx = 0
       fy = 0

   elif model_name == 'motivation_only':
       fx, fy = f_motivation(ped_data, ped_idx, const)

   elif model_name == 'motivation_interaction':
       fxa, fya = f_motivation(ped_data, ped_idx, const)
       fxp, fyp = calc_ped_interaction(ped_data, ped_idx, const)
       fx = fxa + fxp
       fy = fya + fyp

   elif model_name == 'motivation_interaction_wall':
        fxa, fya = f_motivation(ped_data, ped_idx, const)
        fxp, fyp = calc_ped_interaction(ped_data, ped_idx, const)
        fxw, fyw = f_wall(ped_data, ped_idx, const)
        fx = fxa + fxp + fxw
        fy = fya + fyp + fyw

   else:
       fx = np.nan
       fy = np.nan

   last_vx = ped_data['vx'].iloc[ped_idx][-1]
   last_vy = ped_data['vy'].iloc[ped_idx][-1]
   new_vx = last_vx + fx * const['dt']
   new_vy = last_vy + fy * const['dt']

   return new_vx, new_vy


def ped_exit(ped_data, j, act_t, const):
   last_x = ped_data['x'].iloc[j][-1]
   last_y = ped_data['y'].iloc[j][-1]

   exit_dist = math.sqrt((last_x - const['attractor_x'])**2 +
                         (last_y - const['attractor_y'])**2)

   if exit_dist <= const['exit_range']:
       ped_data.at[j, 'time_left'] = act_t
       exit_indication = True

   else:
       exit_indication = False

   return exit_indication


def one_model_run(ped_data, const):
   evacuation_time = np.inf
   act_t = 0
   i = 0
   active_num = const['N_ped']

   while ((i < const['N_step']) & (active_num > 0)):
       act_t = (i+1)*const['dt']

       rep2 = range(const['N_ped'])
       for j in rep2:
           if pd.isna(ped_data.iloc[j]['time_left']):
               act_vx, act_vy = update_v(ped_data, j, 'motivation_interaction_wall', const)
               ped_data = one_ped_step(ped_data, j, act_t, act_vx, act_vy, const)
               exit_indication = ped_exit(ped_data, j, act_t, const)

               if exit_indication:
                   ped_data.at[j, 'time_left'] = act_t
                   active_num -= 1

       i = i+1

   if active_num == 0:
       evacuation_time = act_t
       print(f"All pedestrians evacuated at time {evacuation_time}")
   else:
       print(f"Simulation ended at step {i} with {active_num} pedestrians still active.")


   return evacuation_time, ped_data


#============================================#
#              SCRIPT STARTS HERE            #
#============================================#


#======================#
#     PRELIMINARIES    #
#======================#



# Constants - dictionary

const = {'N_ped': 10,           # numer of peds in the system - to be set in init function
        'N_step': 600,             # maximum number of model steps
        'dt': 0.1,                 # diffrential step length [s]
        'v_opt': 3,                # optimal velocity (scalar) [m/s]
        'tau': 2,                  # motivation force parameter [s]
        'U0': 1,                   # ped intearction potential parameter [J.m]
        'U0_w': 0.1,               # ped intearction potential parameter [J.m]
        'distance_scale': 1,       # ped interaction distance parameter [m]
        'distance_scale_w': 0.5,   # wall interaction distance parameter [m]
        'attractor_x': 1,         # x position of attractor [m]
        'attractor_y': 9,
        'atx2': 4.5,
        'aty2': 9,
        'atx3': 9.5,
        'aty3': 9,
        'atx4': 10.5,
        'aty4': 3,
        'atx5': 8,
        'aty5': 8.5,
        'exit_range': 1,         # distance where ped falls into the exit [m]
        'wx1': 0,                  # wall coordinates [m] - rentangle expected by code, [0,0] expected corner
        'wx2': 15,
        'wy1': 0,
        'wy2': 10,
        'wx3': 0,
        'wy3': 5,
        'wx4': 10,
        'wy4': 5,
        'wx5': 10,
        'wy5': 2,
        'wx6': 10,
        'wy6': 7,
        'wx7' : 0,
        'wy7': 7,
        'wx8': 4,
        'wy8': 7,
        'wx9': 5,
        'wy9': 7,
        'wx10': 9,
        'wy10': 7,
        'wx11': 5,
        'wy11': 5,
       }

# Initialize model data container

max_occupancy = 5
occupancy_range = range(max_occupancy - 1, max_occupancy)
iteration_count = 5
N_ped = const['N_ped']

ped_data, const = init_peds(N_ped, const)

evacuation_time = []

# evacuation_time = np.random.rand(iteration_count,max_occupancy)*np.nan    # container for model output

#======================#

#      SIMULATIONS     #

#======================#

for n in occupancy_range:
    it_range = range(iteration_count)

    for k in it_range:
        print('Model with occupancy ' + str(n) + ' iteration ' + str(k+1) + ' started')
        ped_data, const = init_peds(n+1, const)                     # CREATES MODEL DATA CONTAINER

        time_last_left, ped_data = one_model_run(ped_data, const)   # RUNS MODE

        print('    evacuation time: ' + str(time_last_left))

        evacuation_time.append((n, k, time_last_left))

#======================#

#     POSTPROCESSING   #

#======================#


plt.figure()
print(f"EVACUATION TIMES: {evacuation_time}")
ax = plt.boxplot(evacuation_time)
plt.show()





# # Timespace fundamental diagram x

# plt.figure()

# plt.plot(ped_data.t[0], ped_data.x[0], 'r-', label = 'ped 1')

# plt.plot(ped_data.t[1], ped_data.x[1], 'g-', label = 'ped 2')

# plt.plot(ped_data.t[2], ped_data.x[2], 'b-', label = 'ped 3')

# plt.plot(ped_data.t[3], ped_data.x[3], 'k-', label = 'ped 4')

# plt.plot(ped_data.t[4], ped_data.x[4], 'm-', label = 'ped 5')

# plt.title('Timespace fundamental diagram')

# plt.xlabel(r'$t \,\,\mathrm{[s]}$')

# plt.ylabel(r'$x \,\,\, \mathrm{[m]}$')

# #plt.xlim(0, 10)

# #plt.ylim(0, 120)

# plt.legend()

# plt.show()




# # Aerial plot

# plt.figure()

# plt.plot(const['attractor_x'], const['attractor_y'], 'r*', label = 'ped 1')

# plt.plot(ped_data.x[0], ped_data.y[0], 'r-o', label = 'ped 1')

# plt.plot(ped_data.x[1], ped_data.y[1], 'g-o', label = 'ped 2')

# plt.plot(ped_data.x[2], ped_data.y[2], 'b-o', label = 'ped 3')

# plt.plot(ped_data.x[3], ped_data.y[3], 'k-o', label = 'ped 4')

# plt.plot(ped_data.x[4], ped_data.y[4], 'm-o', label = 'ped 5')

# plt.title('Aerial plot')

# plt.xlabel(r'$x \,\,\mathrm{[m]}$')

# plt.ylabel(r'$y \,\,\, \mathrm{[m]}$')

# #plt.xlim(0, 10)

# #plt.ylim(0, 120)

# plt.legend()

# plt.show()




# # Timespace fundamental diagram y

# plt.figure()

# plt.plot(ped_data.t[0], ped_data.y[0], 'r-', label = 'ped 1')

# plt.plot(ped_data.t[1], ped_data.y[1], 'g-', label = 'ped 2')

# plt.plot(ped_data.t[2], ped_data.y[2], 'b-', label = 'ped 3')

# plt.plot(ped_data.t[3], ped_data.y[3], 'k-', label = 'ped 4')

# plt.plot(ped_data.t[4], ped_data.y[4], 'm-', label = 'ped 5')

# plt.title('Timespace fundamental diagram')

# plt.xlabel(r'$t \,\,\mathrm{[s]}$')

# plt.ylabel(r'$y \,\,\, \mathrm{[m]}$')

# #plt.xlim(0, 10)

# #plt.ylim(0, 120)

# plt.legend()

# plt.show()